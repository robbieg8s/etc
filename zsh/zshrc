# vi mode
bindkey -v
# bindings for insert mode
bindkey "^J" history-beginning-search-forward
bindkey "^K" history-beginning-search-backward
bindkey "^X" vi-cmd-mode
# According to my reading of https://en.wikipedia.org/wiki/ANSI_escape_code (under `Terminal input sequences`),
# these are the vt keycodes. I've set the corresponding keystroke directly in the iTerm config to ensure that
# they're right locally
bindkey "\e[3;3~" backward-delete-word # Alt-Delete
bindkey "\e[3;9~" backward-kill-line   # Cmd-Delete
# bindings for command mode
# bindkey -a ...

## Establish file system context
# Prompt expand %x to get current file, absolutize
ZSHRC="${$(print -P '%x'):A}"
# We want the directory often enough also
ETC_ZSH_DIR="${ZSHRC:h}"

## Sundry zsh options
setopt AUTO_PUSHD
setopt GLOB_DOTS
setopt EXTENDED_GLOB
setopt EXTENDED_HISTORY
setopt HIST_EXPIRE_DUPS_FIRST
setopt HIST_FIND_NO_DUPS
setopt INC_APPEND_HISTORY
setopt NO_AUTO_MENU
setopt PUSHD_IGNORE_DUPS
setopt PUSHD_MINUS
setopt RC_QUOTES

## Sundry zsh parameters
DIRSTACKSIZE=48
HISTFILE="${ETC_ZSH_DIR}"/history
HISTSIZE=1000
SAVEHIST=1000

## Prompt
# Don't export PS variables, because other shells don't understand the zsh escapes
# Don't forget to
#   setopt PROMPT_SUBST
# if you once again set variables in precmd that are used in the prompt
() {
  # Include a note if running dockerized.
  # Probably would be good to extend this to "ssh'd in", etc.
  [[ -e /.dockerenv ]] && local notify_docker=" docker"
  PS1="%F{red}%B:${notify_docker-};%b%f "
  PS2=':%_; '
}

## Configure sqlite shell history
# db location and driver script are in set up in zshenv
# allocate a session per shell invocation
export HALFYAK_ETC_SQLITE_HISTORY_SESSION="$(uuidgen)"
# hook zshaddhistory to save commands, queries have convenience aliases
halfyak_etc_zshaddhistory_sqlite_history_save() {
  # If things aren't set up properly, do a null command. This ensures we don't break regular history in this case.
  # The interactive interface (see aliases file) will fail noisily to get attention.
  "${HALFYAK_ETC_SQLITE_HISTORY:-:}" "${HALFYAK_ETC_SQLITE_HISTORY_DB}" save "${HALFYAK_ETC_SQLITE_HISTORY_SESSION}" "$@"
}
zshaddhistory_functions=($zshaddhistory_functions halfyak_etc_zshaddhistory_sqlite_history_save)

## Environment specific additional configuration
() {
  # For environment variables in the after/zshrc/env directory, source the appropriate value specific file
  local after_envs="${ZSHRC:h}/after/${ZSHRC:t}/env"
  local after_env
  for after_env in "${after_envs}"/*(N)
  do
    local after_env_variable="${after_env:t}"
    [[ -v "${after_env_variable}" ]] && {
      # the variable name (taken from the directory name in the after/zshrc/env) is set,
      # so use (P) to expand it to find the file with the variable specific code,
      # and source it if present
      local after_env_file="${after_env}/${(P)after_env_variable}"
      [[ -r "${after_env_file}" ]] && source "${after_env_file}"
    }
  done
}

## Autocompletion configuration
zstyle ':completion:*' matcher-list '' 'm:{a-zA-Z}={A-Za-z}'
zstyle ':completion:*:*:*:*:messages' format "%d"

autoload -U +X compinit && compinit
# I've experimented with
#   setopt automenu
#   zstyle ':completion:*' menu select
# to get arrow selected completion, but i need to tune/train more to like it

## Interactive aliases
# Remove all other aliases first - this was motivated by misbehaving utilities which add functions
# that shadow executables, but seems reasonable enough to just do in general.
unalias -a
source "${ETC_ZSH_DIR}"/aliases
